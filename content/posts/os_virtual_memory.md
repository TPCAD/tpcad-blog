+++
title = '虚拟内存'
date = 2024-10-20T09:59:27+08:00
tags = ['Operating System']
+++

为了隔离不同进程所使用的地址，操作系统为每个进程分配了一套 **虚拟地址**。各个进程的虚拟内存互相独立，互不干扰，同时，进程也不允许直接访问物理地址。虚拟内存可以让程序访问超出物理内存大小的地址。在 32 位处理器中，虚拟内存的大小为 `4 GB（2^32）`。

## 分页

分页机制将虚拟内存分为一个个大小固定的单元，称为 **页（Page）**。同样的，也将物理内存分为一个个 **页框（Page Frame）**。页和页框的大小相等，通常为 **4 KB**。

### 页表

**页表** 的作用是把页 **映射** 为页框。从数学角度说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。

每一个进程都有自己的页表，页表也存储在内存中，是一个由页表项组成的数组。

#### 页表项

在 32 位操作系统中，一个页表项的大小为 4 字节。

```c
typedef struct page_entry_t
{
    u8 present : 1;  // 在内存中
    u8 write : 1;    // 0 只读，1 可读可写
    u8 user : 1;     // 1 所有人，0 超级用户 DPL < 3
    u8 pwt : 1;      // page write through，1 直写模式，0 回写模式
    u8 pcd : 1;      // page cache disable，禁止该页缓冲
    u8 accessed : 1; // 被访问过，用于统计使用频率
    u8 dirty : 1;    // 脏页，表示该页缓冲被写过
    u8 pat : 1;      // page attribute table，页大小 4K / 4M
    u8 global : 1;   // 全局，所有进程都会用到了，该页不刷新缓冲
    u8 ignored : 3;  // 操作系统决定是否使用
    u32 index : 20;  // 页索引
} _packed page_entry_t;
```

#### 地址转换

在 32 位操作系统中，虚拟内存大小为 4 GB（$2^{32}$），页面大小通常为 4 KB。由此可知，虚拟内存被划分为 1 M（$2^{20}$） 个页面。因此，32 位的虚拟地址中前 20 位表示页索引，剩下 12 位则表示页内偏移量。利用页索引在页表中查找到对应的页框号后，将其与页内偏移量相加即可得到物理地址。

不难发现，页内偏移量的位数与页面大小有关，即当页面大小为 $2^k$ B 时，页内偏移量的位数为 k 位。

![page addressing](https://cdn.xiaolincoding.com//mysql/other/7884f4d8db4949f7a5bb4bbd0f452609.png)

因为页表必须覆盖整个虚拟内存，当一个页表项的大小为 4 B 时，那么页表大小则是 4 MB，若此时有 100 个进程，则需要 400 MB 的内存，这是非常大的浪费。

### 多级页表

多级页表可以有效地节约内存。下面以二级页表为例。

在 32 位操作系统中，32 位虚拟地址中，后 12 位是页内偏移地址，前 20 位中，前 10 位作为一级页号，中间 10 位作为二级页号（不一定是 10 位，在实际中也可能是其他的值）。

在一级页表（或顶级页表）中，页表项存储的是二级页表的地址，而二级页表与单页表的页表项相同，主要存储页框号。

因此，二级页表的寻址过程为：

1. 根据虚拟地址前 10 位在顶级页表中查找二级页表的地址
2. 根据虚拟地址中间 10 位在二级页表中查找页框号
3. 将页框号与页内偏移量相加得到物理地址

![multilevel page](https://cdn.xiaolincoding.com//mysql/other/19296e249b2240c29f9c52be70f611d5.png)

因为一级页号和二级页号的位数都是 10 位，所以一级页表和每个二级页表都有 $2^{10}$ 项，若每项大小为 4 B，则页表大小为 4 KB。

若将所有页表都加载到内存中，二级页表所占用的总内存大小为 4 KB（一级页表）+ 4 MB（所有二级页表），反而比单页表还要大。然而，根据局部性原理，对于大部分程序来说，其使用的空间远远不到 4 GB，因此会存在许多空的页表项。对于二级页表，一级页表就已经可以完整地表示 4 GB 的虚拟地址空间，而二级页表可以在需要时才创建。如此一来，实际加载到内存的页表就只有 4 KB 的一级页表和需要用到的二级页表，最坏的情况也是加载所有的二级页表（几乎不可能），因此，二级页表可以有效地节约内存空间。

无论是单页表还是多级页表，页表都要覆盖全部的虚拟地址空间。如果虚拟地址在页表中没有对应的页表项，计算机就不能工作了。与单页表每个页表项表示 4 KB 内存，需要 100 万个页表项相比，二级页表将页表项进行“压缩”，使一个页表项（一级页表项）可以表示 4 MB，因此只需 1024 个一级页表项就可以表示 4 GB 的虚拟内存空间。

### 倒排页表

倒排页表（Inverted Page Table），也叫反置页表。在这种页表中，以页框号作为页表项的索引，页表项记录的主要内容是进程标识符和页表号。因为物理内存往往比虚拟内存要小得多，所以倒排页表的大小会比普通的单页表要小得多。

倒排页表虽然节约了空间，但却大大增加了检索时间。寻址时，根据进程标识符和页表号检索整个倒排页表（即使页面不在内存中）。当内存容量很大时，页表项的数目还是会非常大。一种方法是采用 **散列表** 来进行存储。通过进程标识符和页表号计算散列值，当散列表的冲突链的平均长度为 1（即散列表的槽数与页框数相等），可以大大提高检索速度。

因为倒排页表只记录了已经调入内存的页面的信息，因此还需要为每个进程建立一个外部页表，以记录那些未被调入内存的页面在外存中的位置。

## 快表

多级页表和倒排页表解决了页表占用空间过大的问题，但地址转换所需要的时间也大大增加。根据局部性原理，可以将程序最常访问的页表项存储在一个高速缓冲中，当 CPU 寻址时优先检索该缓存。

这种缓存称为 **转换检测缓冲区**（Translation Lookaside Buffer，TLB），也称 **相联存储器**（associate memory）或 **快表**。

## 分段

分段机制将内存分成多个 **大小不一**，**可以重叠** 的 **段**（segment）。

### 描述符表

描述符表是一个用于描述内存分布的 **数组**，数组的元素是 **段描述符**，一个段描述符描述一个段。x86 处理器中有两种描述符表，分别是全局描述符表（Global Descriptor Table，GDT）和局部描述符表（Local Descriptor Table，LDT）。GDT 描述系统段，包括操作系统本身，一台计算机上只有一个 GDT。LDT 描述程序的段，包括代码，数据，堆栈等，每个进程都有自己的 LDT。

描述符表的第一项必须是全 0，且不应被使用。

### gdtr

全局描述符表寄存器（gdtr）用于存储 GDT。寄存器大小（32 位系统）是 6 字节。低 2 字节指明 GDT 的大小，也就是说 GDT 最大为 $2^{16}$ 字节。高 4 字节指明 GDT 的地址。

相应地，LDT 被存储于 ldtr 中。

### 段描述符

段描述符是描述符表的元素，用于描述一个内存中的一个段。段描述符主要存储了段的基址、限长以及一些属性位。

![segment descriptor](https://habrastorage.org/r/w1560/storage1/c46ddde2/3ff7d2f3/6af3408f/0d65fa31.jpg)

### 段选择子

段选择子（segment selector）是一个 2 字节大小的数据结构，用于定位段描述符，通常保存在段寄存器中。段选择子的结构如下所示：

- 0～1：RPL
- 2：0 表示全局描述符，1 表示本地描述符
- 3～15：GDT 索引

从其结构可以看出，索引只有 13 位，也就是说描述符表最多有 $2^{13}$ 个段描述符。

### 地址转换

在寻址之前，需要先把段选择子保存到段寄存器中。根据段选择子在 GDT 或 LDT 中找到对应的段描述符，根据其中的段界限字段判断段内偏移量（即给出的虚拟地址）是否有效，若有效，则将段描述符中的段基地址与段内偏移量相加，得到物理地址。

### 分段机制的问题

分段机制会带来 **外部内存碎片** 和 **内存交换效率低** 的问题。

分段机制根据段的实际需求分配内存，因此不会出现 **内部内存碎片**。当内存中的一些段不再使用，被回收后，就会出现多个 **不连续** 的小物理内存，这就是 **外部内存碎片**。这会导致新的程序没有足够的空间去装载。

为了解决外部内存碎片问题，可以把一些段先写入到硬盘，再将其读回内存，使其紧跟在其他段的后面，从而得到更大的连续内存空间。然而，读写硬盘的速度要远远慢于读写内存的速度，所以如果内存交换的是一个很大的程序，就会造成明显卡顿。

## 段页式内存管理

分段和分页并不是互不兼容的，它们可以组合起来在同一系统上使用。事实上，x86 处理器上分段和分页机制同时存在。

段页式内存管理先将程序划分成不同的段，每个段以页为基本单位进行分配。在寻址时，需要先通过描述符表找到段所对应的页表的地址，再通过页表将地址转换为物理地址。

## Linux 的内存管理

Linux 的内存管理以分页为主，最小限度地使用分段。

Linux 将所有段的基地址设为 0，限长设为最大值。如此一来，逻辑地址就与线性地址相同了。

## 其他

### 局部性原理

CPU 在访问内存时有明显的重复性。具体表现为 **时间局部性** 和 **空间局部性**。

1. 时间局部性：如果一个存储单元被访问，那么不久之后可能再次被访问
2. 空间局部性：如果一个存储单元被访问，那么其附近的内存也将被访问
