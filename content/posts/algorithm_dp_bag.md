+++
title = '背包问题'
date = 2024-12-24T14:56:44+08:00
draft = true
+++

## 0-1 背包问题

> 有 n 件物品和有一个容量为 W 的背包。第 i 件物品的重量为 `w[i]`，价值为 `v[i]`，每件物品有且只有 1 件。请问在总重量不超过背包容量的情况下，能装入背包的最大价值是多少？

每种物品只有「取」和「不取」两种可能的状态。设 `dp[i][j]` 为只能放前 `i` 件物品的情况下，容量为 `j` 的背包所能达到的最大价值，其中 `0 <= i <= n, 0 <= j <= W`。当 `i == 0` 或 `j == 0`，`dp[i][j] == 0`。

对于第 `i` 件物品，若「不取」，问题转化为只能放前 `i - 1` 件物品的情况下，容量为 `j` 的背包所能达到的最大价值，这种情况的最大价值为 `dp[i-1][j]`；

若「取」，背包的剩余容量会减少 `w[i]`，背包中物品的总价值会增加 `v[i]`，问题转化为只能放前 `i - 1` 件物品的情况下，容量为 `j - w[i]` 的背包所能达到的最大价值，这种情况的最大价值为 `dp[i-1][j-w[i]] + v[i]`。

由此可得状态转移方程：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])`。

也可以使用一维数组记录状态，此时状态转移方程为：`dp[j] = max(dp[j], dp[j-w[i]] + v[i])`。

根据状态方程很容易得到这样的核心代码：

```cpp
std::vector<int> dp(W + 1, 0);

for (int i = 1; i <= n; i++) {
    for (int j = w[i]; j <= W; j++) {
        dp[j] = std::max(dp[j], dp[j - w[i]] + v[i]);
    }
}
```

假设前 `i` 件物品在达到的最大价值时的背包容量为 `k`，`dp[k] = maxk` 

如果遍历 `[1, W]`，需要判断当前背包容量上限 `j` 能否装入当前物品，所以遍历比当前物品重量小的背包容量是无意义的。
